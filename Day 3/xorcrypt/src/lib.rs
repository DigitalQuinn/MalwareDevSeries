use proc_macro::TokenStream;

#[proc_macro]
pub fn prepare_encryption(_tokens: proc_macro::TokenStream) -> proc_macro::TokenStream {
    use rand::distributions::Alphanumeric;
    use rand::{thread_rng, Rng};
    let key: String =
        String::from_utf8(thread_rng().sample_iter(&Alphanumeric).take(20).collect()).unwrap();
    std::env::set_var("ENCRYPT", &key);
    format!(
        "
    use base64;
    const BASE_KEY: &[u8] = b\"{}\";
    fn xor(input: &[u8]) -> Vec<u8> {{
        let key = BASE_KEY.repeat((input.len()/BASE_KEY.len()) + 1)[..input.len()].to_vec();
        input
            .iter()
            .zip(key)
            .map(|(x, y)| *x ^ y)
            .collect::<Vec<u8>>()
    }}
    fn decrypt(input: String) -> String {{
        let xored = base64::decode(input.as_bytes()).unwrap();
        String::from_utf8(xor(xored.as_slice())).unwrap()
    }}",
        key
    )
    .parse()
    .unwrap()
}
#[proc_macro]
pub fn e(_tokens: proc_macro::TokenStream) -> proc_macro::TokenStream {
    encrypt_string(TokenStream::from(_tokens))
}

fn encrypt_string(tokens: TokenStream) -> TokenStream {
    let tokens = tokens.to_string();
    let tokens = tokens[1..tokens.len() - 1].to_string();
    let output = xor(tokens.as_bytes());
    let output = base64::encode(output);
    let output_func = format!("decrypt(\"{}\".to_string())", output);
    output_func.parse().unwrap()
    // format!("\"{}\"", output).parse().unwrap()
}

fn xor(input: &[u8]) -> Vec<u8> {
    let key = std::env::var("ENCRYPT").unwrap();
    let key = key.repeat((input.len() / key.len()) + 1);
    let key = key[..input.len()].as_bytes().to_vec();
    input
        .iter()
        .zip(key)
        .map(|(x, y)| *x ^ y)
        .collect::<Vec<u8>>()
}
