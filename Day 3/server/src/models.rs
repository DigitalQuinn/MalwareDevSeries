use std::sync::Arc;

use tokio::{
    io::{AsyncReadExt, AsyncWriteExt},
    net::TcpStream,
    sync::Mutex,
};

pub struct Client {
    pub socket: TcpStream,
    pub addr: String,
}

impl Client {
    pub async fn read(&mut self) -> std::io::Result<Vec<u8>> {
        let mut read_buf: Vec<u8> = vec![];
        let termination = b"::OVER::";
        while !substr_exists(&read_buf, termination).await {
            let mut buf = vec![0u8; 4096 * 4096];
            match self.socket.read(&mut buf).await {
                Ok(_) => read_buf.append(&mut buf),
                Err(e) => return Err(e),
            }
        }

        if let Some(position) = find_position(&read_buf, termination).await {
            read_buf = read_buf[..position].to_vec();
        }
        Ok(read_buf)
    }

    pub async fn write(&mut self, data: &[u8]) -> std::io::Result<()> {
        let mut data = data.to_vec();
        data.append(&mut b"::OVER::".to_vec());
        self.socket.write_all(data.as_slice()).await
    }

    pub async fn write_file(&mut self, data: Vec<u8>, filename: &[u8]) -> std::io::Result<()> {
        let mut start_seq = b"::STARTFILE::".to_vec();
        let mut start_data = b"::STARTDATA::".to_vec();
        let mut stop_seq = b"::ENDFILE::".to_vec();

        let mut file_data: Vec<u8> = vec![];

        file_data.append(&mut start_seq);
        file_data.append(&mut filename.to_vec());
        file_data.append(&mut start_data);
        file_data.append(&mut data.to_vec());
        file_data.append(&mut stop_seq);
        file_data.append(&mut b"::OVER::".to_vec());

        self.socket.write_all(file_data.as_slice()).await
    }
}
pub type ClientList = Arc<Mutex<Vec<Client>>>;

async fn find_position(buf: &Vec<u8>, needle: &[u8]) -> Option<usize> {
    buf.windows(needle.len()).position(|x| x == needle)
}

async fn substr_exists(buf: &Vec<u8>, needle: &[u8]) -> bool {
    match find_position(buf, needle).await {
        Some(_) => true,
        None => false,
    }
}
